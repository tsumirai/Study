# TCP的三次握手与四次挥手
TCP工作在网络OSI的七层模型中的第四层——传输层，IP在第三层——网络层，ARP在第二层——数据链路层。  
在第二层上的数据，我们把它叫做帧，在第三层上的数据叫包，第四层的数据叫段。  
数据从应用层发下来，会在每一次的头部加上信息，进行封装，然后再发送到数据接收端。也就是每个数据都会经过封装和解封装的过程。在OSI七层模型中，每一层的作用和对应的协议如下：  
OSI中的层 | 功能 | 协议族  
:-: | :-: | :-:  
应用层 | 文件传输，电子邮件，文件服务，虚拟终端 | TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet  
表示层 | 数据格式化，代码转换，数据加密 | 没有协议  
会话层 | 解除或建立与别的节点的联系 | 没有协议  
传输层 | 提供端对端的接口 | TCP，UDP  
网络层 | 为数据包选择路由 | IP，ICMP，RIP，OSPF，BGP，IGMP  
数据链路层 | 传输有地址的帧以及错误检测功能 | SLIP，CSLIP，PPP，ARP，RARP，MTU  
物理层 | 以二进制数据形式在物理媒体上传输数据 | ISO2110，IEEE802，IEEE802.2  
![20180717201939345.jpg](20180717201939345.jpg)  
序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的序号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。  
确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。  
确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效。  
同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示，这是一个连接请求报文段。若同意连接，则在响应报文段中使SYN=1，ACK=1.因此SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建立连接时才会被置为1，握手完成后SYN标志位被置为0。  
终止FIN：用来释放一个连接。FIN=1表示，此报文段的发送方数据已经发送完毕，并要求释放运输连接。  
PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0，ack、seq小写的单词表示序号。  
字段 | 含义  
:-: | :-:  
URG | 紧急指针是否有效。为1，表示某一位需要被优先处理  
ACK | 确认号是否有效，一般置为1  
PSH | 提示接收端应用程序立即从TCP缓冲区把数据读走  
RST | 对方要求重新建立连接，复位  
SYN | 请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1  
FIN | 希望断开连接    
## 三次握手
第一次握手：主机A发送位码为SYN=1，随机产生seq number=x的数据包到服务器，客户端进入SYN_SEND状态，等待服务器的确认；主机B由SYN=1知道，A要求建立联机。  
第二次握手：主机B收到请求后要确认联机信息，向A发送ack number（主机A的seq+1），SYN=1，ACK=1，随机产生seq=y的包，此时服务器进入SYN_RECV（半连接）状态；  
第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码ACK是否为1，若正确，主机A会再发送ack number（主机B的seq+1），ACK=1，主机B收到后确认seq值与ACK=1则连接建立成功，完成TCP三次握手。  
TCP位码，有6种标示：SYN（synchronous建立联机）、ACK（acknowledgement确认）、PSH（push传送）、FIN（finish结束）、RST（reset重置）、URG（urgent紧急）、Sequence number（顺序号码）、Acknowledge number（确认号码）。  
![20180717202520531.png](20180717202520531.png)    
## 四次挥手
1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN_WAIT_1（终止等待1）状态。TCP规定，FIN报文即使不携带数据，也要消耗一个序号。    
2. 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE_WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE_WAIT状态持续的时间。  
3. 客户端收到服务器的确认请求后，此时，客户端就进入FIN_WAIT_2（终止等待2）状态，等待服务器发送链接释放报文（在这之前还需要接受服务器发送的最后的数据）。  
4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时服务器就进入了LAST_ACK（最后确认）状态，等待客户端的确认。  
5. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME_WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。  
6. 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。   

# 常见面试题  
1. 为什么连接的时候是三次握手，关闭的时候却是四次挥手？  

因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能仙女回复一个ACK报文，告诉Client端，“你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。    
2. 为什么TIME_WAIT状态需要经过2MSL（最大报文段生存时间）才能返回到CLOSE状态？  

虽然按道理，四个报文都发送完毕，我们就可以直接进入CLOSE状态了，但是我们必须假想网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL（Maximum Segment Lifetime）。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。
