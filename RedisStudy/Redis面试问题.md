# 什么是Redis
Redis是一个使用C语言写成的，开源的key-value数据库。和Memcached类似，它支持存储的value类型相对更多，包括string（字符串）、list（链表）、set（集合）、zset（有序集合）和hash（哈希）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave（主从）同步。  
# Redis与Memcached的区别与比较
1. redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcached支持简单的数据类型，string。
2. redis支持数据的备份，即master-slave模式的数据备份。
3. redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而memcached把数据全部存在内存中。
4. redis的速度比memcached快很多。
5. memcached是多线程，非阻塞IO复用的网络模型，redis使用单线程的IO复用模型

对比参数 | redis | memcached  
:-: | :-: | :-:
类型 | 1、支持内存<br>2、非关系型数据库 | 1、支持内存<br>2、key-value键值对形式<br>3、缓存系统  
数据存储类型 | 1、string<br>2、list<br>3、set<br>4、hash<br>5、sort set（俗称zset） | 1、文本型<br>2、二进制类型（新版增加）  
查询（操作）类型 | 1、批量操作<br>2、事务支持（虽然是假的事务）<br>3、每个类型不同的CRUD | 1、CRUD<br>2、少量的其他命令  
附加功能 | 1、批量操作<br>2、主从分区<br>3、序列化支持<br>4、脚本支持（lua脚本） | 1、多线程服务支持  
网络IO模型 | 1、单线程模式 | 1、多线程、非阻塞IO模式  
事件库 | 自封装简易事件库AeEvent | 贵族血统的LibEvent事件库  
持久化支持 | 1、RDB<br>2、AOF | 不支持  
# Redis与Memcached的选择
终极策略：使用redis的string类型做的事，都可以用memcached替换，以此换取更好的性能提升；除此以外，优先考虑redis
# 使用redis有哪些好处
1. 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
2. 支持丰富数据类型，支持string，list，set，sort set，hash
3. 支持事务，操作都是原子性，所谓原子性就是对数据的更改要么全部执行，要么全部不执行
4. 丰富的特性，可用于缓存，消息，按key设置过期时间，过期后将会自动删除

# Redis常见数据结构使用场景
## string
常用命令：set，get，decr，incr，mget等  
string数据结构是简单的key-value类型，value其实不仅可以是string，也可以是数字。  
常规key-value缓存应用；  
常规计数：微博数，粉丝数等。
## hash
常用命令：hget,hset,hgetall等  
hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。比如我们可以hash数据结构来存储用户信息，商品信息等等。  
## list
常用命令：lpush，rpush，lpop，rpop，lrange等。  
list就是链表，redis list的应用场景非常多，也是redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，最新消息排行等功能都可以用redis的list结构来实现。  
redis list的实现为一个双向链表，既可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。  
## set
常用命令：sadd，spop，smembers，sunion等。  
set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的。  
当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。  
在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在另一个集合中。redis可以非常方便的实现如共同关注、共同喜好、二者好友等功能。
## sorted set
常用命令：zadd，zrange，zrem，zcard等  
和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按照score进行有序排列。  
举例：在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用redis中的sorted set结构进行存储。
## redis数据淘汰策略
当redis内存数据集大小上升到一定程度的时候，就会实行数据淘汰策略（回收策略）  
1. volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰。  
2. volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰。  
3. volatile-random：从已设置过期时间的数据集（server.db[i].expires）中挑选任意数据淘汰。  
4. allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰。
5. allkeys-random：从数据集（server.db[i].dict）中挑选任意数据淘汰。  
6. no-enviction：禁止驱逐数据

## redis的并发竞争问题如何解决
redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。redis本身没有锁的概念，redis对于多个客户端连接并不存在金正，但是在Jedis客户端对redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此，有两种解决方法：  
1. 客户端角度，为保证每个客户端间正常有序与redis进行通信，对连接进行池化，同时对客户端读写redis操作采用内部锁synchronized。
2. 服务器角度，利用setnx实现锁。  

## redis常见性能问题和解决方案
1. master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件。
2. 如果数据比较重要，某个slave开启AOF备份数据，策略设置为每秒同步一次。
3. 为了主从复制的速度和连接的稳定性，master和slave最好在同一个局域网内。
4. 尽量避免在压力很大的主库上增加从库。

## redis与消息队列
不要使用redis去做消息队列，这不是redis的设计目标。但实在太多人使用redis去做消息队列，redis的作者看不下去，另外基于redis的核心代码，另外实现了一个消息队列disque，部署、协议等方面都跟redis非常类似，并且支持集群，延迟消息等等。

# redis的持久化和缓存机制
## redis的适用环境
首先作为一个nosql的key-value组成的数据库，它们能存储的数据结构必须是简单的，因为有关系的数据即使存储进去之后查询也是很困难的，并且对于海量的数据存储，还是关系型数据库比较合适。  
那么什么样的数据适合存储在非关系型数据库中呢？  
1. 关系不是很密切的数据
2. 量比较大的数据
3. 访问比较频繁的数据

## 持久化
redis支持两种持久化方式，一种是snapshotting（快照）也是默认方式，另一种是Append-only File（AOF）的方式。  
### Snapshotting  

快照是默认的持久化方式，这种方式就是将内存中的数据以快照的方式写入到二进制文件中，默认的文件名为dump.rdb。可以通过配置设置自动做快照持久化的方式。我们可以配置redis在n秒内如果超过m个key被修改就自动做快照，下面是默认的快照保存配置：  
* save 900 1 //900秒内如果1个key被修改，则发起快照保存
* save 300 10 //300秒内如果超过10个key被修改，则发起快照保存

下面介绍详细的快照保存过程：  
1. redis调用fork，现在有了子进程和父进程。
2. 父进程急需处理client请求，子进程负责将内存内容写入到临时文件中。由于os的实时复制机制（copy on write）父子进程会共享相同的物理页面，当父进程处理写请求时os会为父进程要修改的页面创建副本，而不是写共享的页面。所以子进程地址空间内的数据就是fork时刻整个数据库的一个快照。
3. 当子进程将快照写入临时文件完毕后，用临时文件替换原来的快照文件，然后子进程退出。client也可以使用save或者bgsave命令通知redis做一次快照持久化。save操作是在主线程中保存快照的，由于redis是用一个主线程来处理所有client的请求，这种方式会阻塞所有client请求。所以不推荐使用。另一点需要注意的是，每次快照持久化都是将内存数据完整写入到磁盘一次，并不是增量的只同步变更数据。如果数据量大的话，而且写操作比较多，必然会引起大量的磁盘io操作，可能会严重影响性能。

### AOF方式
由于快照方式是在一定间隔时间做一次，所以如果redis以外down掉的话，就会丢失最后一次快照后的所有修改。如果应用要求不能丢失任何修改的话，可以采用aof持久化方式。AOF比快照方式有更好的持久化性，是由于在使用AOF持久化方式时，redis会将每一个收到的写命令都通过write函数追加到文件中（默认是appendonly.aof）。当redis重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。当然由于os会在内核中缓存write做的修改，所以可能不是立即写到磁盘上。这样aof方式的持久化也还是有可能会丢失部分修改。不过我们可以通过配置文件告诉redis我们想要通过fsync函数强制os写入到磁盘的时机。有以下三种方式（默认是每秒fsync一次）：  
appendonly yes //启用持久化方式  
1. appendfsync always //收到写命令就立即写入磁盘，最慢，但是保证完全的持久化
2. appendfsync everysec //每秒钟写入磁盘一次，在性能和持久化方面做了很好的折中
3. appendfsync no //完全依赖os，性能最好，持久化没有保证  

aof的方式也同时带来了另一个问题。持久化文件会变得越来越大。例如我们调用incr test命令100次，文件中必须保存全部的100条命令，其实有99条是多余的。因为要恢复数据库的状态其实文件中保存一条set test 100就够了。为了压缩aof的持久化文件，redis提供了bgrewriteaof命令，收到此命令redis将使用与快照类似的方式将内存中的数据以命令的方式保存到临时文件中，最后替换原来的文件。

# Redis内存回收
redus中采用两种算法进行内存回收，引用计数算法以及LRU算法。  
LRU算法作为内存管理的一种有效算法，其含义是在内存优先的情况下，当内存容量不足时，为了保证程序的运行，这时就不得不淘汰内存中的一些对象，释放这些对象占用的空间，那么选择淘汰那些对象呢？LRU算法就提供了一种策略，告诉我们选择最近一段时间内，最久未使用的对象将其淘汰。  
在操作系统中LRU算法淘汰的不是内存中的对象，而是页，当内存中数据不足时，通过LRU算法，选择一页（通常是4kb）将其交换到虚拟内存区（swap区）  
LRU算法演示  
![251954349742220.png](251954349742220.png)  
假设前提，只有三块内存空间可以使用，每一块内存空间只能存放一个对象，如A、B、C...  
1. 最开始时，内存空间是空的，因此依次进入A、B、C是没有问题的。
2. 当加入D时，就出现了问题，内存空间不够了，因此根据LRU算法，内存空间中A待的时间最为久远，选择A，将其淘汰。
3. 当再次引用B时，内存空间中的B又处于活跃状态，而C则变成了内存空间中，近段时间最久未使用的。
4. 当再次向内存空间加入E时，这时内存空间又不足了，选择在内存空间中待的最久的C将其淘汰出内存，这时的内存空间存放的对象就是E->B->D  